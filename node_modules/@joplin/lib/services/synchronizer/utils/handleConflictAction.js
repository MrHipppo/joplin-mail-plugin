"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("@joplin/utils/Logger");
const BaseItem_1 = require("../../../models/BaseItem");
const ItemChange_1 = require("../../../models/ItemChange");
const Note_1 = require("../../../models/Note");
const Resource_1 = require("../../../models/Resource");
const time_1 = require("../../../time");
const logger = Logger_1.default.create('handleConflictAction');
exports.default = (action, ItemClass, remoteExists, remoteContent, local, syncTargetId, itemIsReadOnly, dispatch) => __awaiter(void 0, void 0, void 0, function* () {
    logger.debug(`Handling conflict: ${action}`);
    logger.debug('remoteExists:', remoteExists);
    if (action === 'itemConflict') {
        // ------------------------------------------------------------------------------
        // For non-note conflicts, we take the remote version (i.e. the version that was
        // synced first) and overwrite the local content.
        // ------------------------------------------------------------------------------
        if (remoteExists) {
            local = remoteContent;
            const syncTimeQueries = BaseItem_1.default.updateSyncTimeQueries(syncTargetId, local, time_1.default.unixMs());
            yield ItemClass.save(local, { autoTimestamp: false, changeSource: ItemChange_1.default.SOURCE_SYNC, nextQueries: syncTimeQueries });
        }
        else {
            yield ItemClass.delete(local.id, {
                changeSource: ItemChange_1.default.SOURCE_SYNC,
                trackDeleted: false,
            });
        }
    }
    else if (action === 'noteConflict') {
        // ------------------------------------------------------------------------------
        // First find out if the conflict matters. For example, if the conflict is on the title or body
        // we want to preserve all the changes. If it's on todo_completed it doesn't really matter
        // so in this case we just take the remote content.
        // ------------------------------------------------------------------------------
        let mustHandleConflict = true;
        if (!itemIsReadOnly && remoteContent) {
            mustHandleConflict = Note_1.default.mustHandleConflict(local, remoteContent);
        }
        // ------------------------------------------------------------------------------
        // Create a duplicate of local note into Conflicts folder
        // (to preserve the user's changes)
        // ------------------------------------------------------------------------------
        if (mustHandleConflict) {
            yield Note_1.default.createConflictNote(local, ItemChange_1.default.SOURCE_SYNC);
        }
    }
    else if (action === 'resourceConflict') {
        // ------------------------------------------------------------------------------
        // Unlike notes we always handle the conflict for resources
        // ------------------------------------------------------------------------------
        yield Resource_1.default.createConflictResourceNote(local);
        if (remoteExists) {
            // The local content we have is no longer valid and should be re-downloaded
            yield Resource_1.default.setLocalState(local.id, {
                fetch_status: Resource_1.default.FETCH_STATUS_IDLE,
            });
        }
        dispatch({ type: 'SYNC_CREATED_OR_UPDATED_RESOURCE', id: local.id });
    }
    if (['noteConflict', 'resourceConflict'].includes(action)) {
        // ------------------------------------------------------------------------------
        // For note and resource conflicts, the creation of the conflict item is done
        // differently. However the way the local content is handled is the same.
        // Either copy the remote content to local or, if the remote content has
        // been deleted, delete the local content.
        // ------------------------------------------------------------------------------
        if (remoteExists) {
            local = remoteContent;
            const syncTimeQueries = BaseItem_1.default.updateSyncTimeQueries(syncTargetId, local, time_1.default.unixMs());
            yield ItemClass.save(local, { autoTimestamp: false, changeSource: ItemChange_1.default.SOURCE_SYNC, nextQueries: syncTimeQueries });
            if (local.encryption_applied)
                dispatch({ type: 'SYNC_GOT_ENCRYPTED_ITEM' });
        }
        else {
            // Remote no longer exists (note deleted) so delete local one too
            yield ItemClass.delete(local.id, { changeSource: ItemChange_1.default.SOURCE_SYNC, trackDeleted: false });
        }
    }
});
//# sourceMappingURL=handleConflictAction.js.map