"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_utils_1 = require("../../testing/test-utils");
const MasterKey_1 = require("../../models/MasterKey");
const syncInfoUtils_1 = require("./syncInfoUtils");
describe('syncInfoUtils', () => {
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
    }));
    afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, test_utils_1.afterAllCleanUp)();
    }));
    it('should enable or disable a master key', () => __awaiter(void 0, void 0, void 0, function* () {
        const mk1 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey('111111'));
        const mk2 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey('111111'));
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk2.id, false);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk1.id))).toBe(true);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk2.id))).toBe(false);
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk1.id, false);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk1.id))).toBe(false);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk2.id))).toBe(false);
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk1.id, true);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk1.id))).toBe(true);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk2.id))).toBe(false);
    }));
    it('should tell if two sync info are equal', () => __awaiter(void 0, void 0, void 0, function* () {
        {
            const syncInfo1 = new syncInfoUtils_1.SyncInfo();
            const syncInfo2 = new syncInfoUtils_1.SyncInfo();
            expect((0, syncInfoUtils_1.syncInfoEquals)(syncInfo1, syncInfo2)).toBe(true);
        }
        {
            const syncInfo1 = new syncInfoUtils_1.SyncInfo();
            syncInfo1.masterKeys = [{
                    id: 'id',
                    content: 'content',
                }];
            const syncInfo2 = new syncInfoUtils_1.SyncInfo();
            syncInfo2.masterKeys = [{
                    id: 'id',
                    content: 'different',
                }];
            expect((0, syncInfoUtils_1.syncInfoEquals)(syncInfo1, syncInfo2)).toBe(false);
        }
        {
            const syncInfo1 = new syncInfoUtils_1.SyncInfo();
            syncInfo1.masterKeys = [{
                    id: 'id',
                    content: 'content',
                }];
            const syncInfo2 = new syncInfoUtils_1.SyncInfo();
            syncInfo2.masterKeys = [{
                    id: 'id',
                    content: 'content',
                }];
            expect((0, syncInfoUtils_1.syncInfoEquals)(syncInfo1, syncInfo2)).toBe(true);
        }
        {
            // Should disregard object key order
            const syncInfo1 = new syncInfoUtils_1.SyncInfo();
            syncInfo1.masterKeys = [{
                    content: 'content',
                    id: 'id',
                }];
            const syncInfo2 = new syncInfoUtils_1.SyncInfo();
            syncInfo2.masterKeys = [{
                    id: 'id',
                    content: 'content',
                }];
            expect((0, syncInfoUtils_1.syncInfoEquals)(syncInfo1, syncInfo2)).toBe(true);
        }
    }));
    it('should merge sync target info and takes into account usage of master key - 1', () => __awaiter(void 0, void 0, void 0, function* () {
        const syncInfo1 = new syncInfoUtils_1.SyncInfo();
        syncInfo1.masterKeys = [{
                id: '1',
                content: 'content1',
                hasBeenUsed: true,
            }];
        syncInfo1.activeMasterKeyId = '1';
        yield (0, test_utils_1.msleep)(1);
        const syncInfo2 = new syncInfoUtils_1.SyncInfo();
        syncInfo2.masterKeys = [{
                id: '2',
                content: 'content2',
                hasBeenUsed: false,
            }];
        syncInfo2.activeMasterKeyId = '2';
        // If one master key has been used and the other not, it should select
        // the one that's been used regardless of timestamps.
        expect((0, syncInfoUtils_1.mergeSyncInfos)(syncInfo1, syncInfo2).activeMasterKeyId).toBe('1');
        // If both master keys have been used it should rely on timestamp
        // (latest modified is picked).
        syncInfo2.masterKeys[0].hasBeenUsed = true;
        expect((0, syncInfoUtils_1.mergeSyncInfos)(syncInfo1, syncInfo2).activeMasterKeyId).toBe('2');
    }));
    it('should merge sync target info, but should not make a disabled key the active one', () => __awaiter(void 0, void 0, void 0, function* () {
        const syncInfo1 = new syncInfoUtils_1.SyncInfo();
        syncInfo1.masterKeys = [{
                id: '1',
                content: 'content1',
                hasBeenUsed: true,
                enabled: 0,
            }];
        syncInfo1.activeMasterKeyId = '1';
        yield (0, test_utils_1.msleep)(1);
        const syncInfo2 = new syncInfoUtils_1.SyncInfo();
        syncInfo2.masterKeys = [{
                id: '2',
                content: 'content2',
                enabled: 1,
                hasBeenUsed: false,
            }];
        syncInfo2.activeMasterKeyId = '2';
        // Normally, if one master key has been used (1) and the other not (2),
        // it should select the one that's been used regardless of timestamps.
        // **However**, if the key 1 has been disabled by user, it should
        // **not** be picked as the active one. Instead it should use key 2,
        // because it's still enabled.
        expect((0, syncInfoUtils_1.mergeSyncInfos)(syncInfo1, syncInfo2).activeMasterKeyId).toBe('2');
        // If both key are disabled, we go back to the original logic, where we
        // select the key that's been used.
        syncInfo2.masterKeys[0].enabled = 0;
        expect((0, syncInfoUtils_1.mergeSyncInfos)(syncInfo1, syncInfo2).activeMasterKeyId).toBe('1');
    }));
    it('should fix the sync info if it contains invalid data', () => __awaiter(void 0, void 0, void 0, function* () {
        test_utils_1.logger.enabled = false;
        const syncInfo = new syncInfoUtils_1.SyncInfo();
        syncInfo.masterKeys = [{
                id: '1',
                content: 'content1',
                hasBeenUsed: true,
                enabled: 0,
            }];
        syncInfo.activeMasterKeyId = '2';
        (0, syncInfoUtils_1.saveLocalSyncInfo)(syncInfo);
        const loaded = (0, syncInfoUtils_1.localSyncInfo)();
        expect(loaded.activeMasterKeyId).toBe('');
        expect(loaded.masterKeys.length).toBe(1);
        test_utils_1.logger.enabled = true;
    }));
});
//# sourceMappingURL=syncInfoUtils.test.js.map