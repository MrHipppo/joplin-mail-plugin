"use strict";
/* eslint-disable multiline-comment-style */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = require("../../../models/Resource");
const Setting_1 = require("../../../models/Setting");
const shim_1 = require("../../../shim");
/**
 * Provides imaging functions to resize or process images. You create an image
 * using one of the `createFrom` functions, then use the other functions to
 * process the image.
 *
 * Images are associated with a handle which is what will be available to the
 * plugin. Once you are done with an image, free it using the `free()` function.
 *
 * [View the
 * example](https://github.com/laurent22/joplin/blob/dev/packages/app-cli/tests/support/plugins/imaging/src/index.ts)
 *
 */
class JoplinImaging {
    constructor(implementation) {
        this.images_ = [];
        this.implementation_ = implementation;
    }
    createImageHandle() {
        return [Date.now(), Math.random()].join(':');
    }
    imageByHandle(handle) {
        const image = this.images_.find(i => i.handle === handle);
        if (!image)
            throw new Error(`No image with handle ${handle}`);
        return image;
    }
    cacheImage(data) {
        const handle = this.createImageHandle();
        this.images_.push({
            handle,
            data,
        });
        return handle;
    }
    // Create an image from a buffer - however only use this for very small
    // images. It requires transferring the full image data from the plugin to
    // the app, which is extremely slow and will freeze the app. Instead, use
    // `createFromPath` or `createFromResource`, which will manipulate the image
    // data directly from the main process.
    //
    // public async createFromBuffer(buffer: any, options: CreateFromBufferOptions = null): Promise<Handle> {
    // 	return this.cacheImage(this.implementation_.nativeImage.createFromBuffer(buffer, options));
    // }
    createFromPath(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cacheImage(this.implementation_.nativeImage.createFromPath(filePath));
        });
    }
    createFromResource(resourceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = yield Resource_1.default.load(resourceId);
            if (!resource)
                throw new Error(`No such resource: ${resourceId}`);
            const resourcePath = yield Resource_1.default.fullPath(resource);
            if (!(yield shim_1.default.fsDriver().exists(resourcePath)))
                throw new Error(`Could not load resource path: ${resourcePath}`);
            return this.createFromPath(resourcePath);
        });
    }
    getSize(handle) {
        return __awaiter(this, void 0, void 0, function* () {
            const image = this.imageByHandle(handle);
            return image.data.getSize();
        });
    }
    resize(handle, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const image = this.imageByHandle(handle);
            const resizedImage = image.data.resize(options);
            return this.cacheImage(resizedImage);
        });
    }
    crop(handle, rectange) {
        return __awaiter(this, void 0, void 0, function* () {
            const image = this.imageByHandle(handle);
            const croppedImage = image.data.crop(rectange);
            return this.cacheImage(croppedImage);
        });
    }
    // Warning: requires transferring the complete image from the app to the
    // plugin which may freeze the app. Consider using one of the `toXxxFile()`
    // or `toXxxResource()` methods instead.
    //
    // public async toDataUrl(handle: Handle): Promise<string> {
    // 	const image = this.imageByHandle(handle);
    // 	return image.data.toDataURL();
    // }
    // Warnings: requires transferring the complete image from the app to the
    // plugin which may freeze the app. Consider using one of the `toXxxFile()`
    // or `toXxxResource()` methods instead.
    //
    // public async toBase64(handle: Handle) {
    // 	const dataUrl = await this.toDataUrl(handle);
    // 	const s = dataUrl.split('base64,');
    // 	if (s.length !== 2) throw new Error('Could not convert to base64');
    // 	return s[1];
    // }
    toPngFile(handle, filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const image = this.imageByHandle(handle);
            const data = image.data.toPNG();
            yield shim_1.default.fsDriver().writeFile(filePath, data, 'buffer');
        });
    }
    /**
     * Quality is between 0 and 100
     */
    toJpgFile(handle, filePath, quality = 80) {
        return __awaiter(this, void 0, void 0, function* () {
            const image = this.imageByHandle(handle);
            const data = image.data.toJPEG(quality);
            yield shim_1.default.fsDriver().writeFile(filePath, data, 'buffer');
        });
    }
    tempFilePath(ext) {
        return `${Setting_1.default.value('tempDir')}/${Date.now()}_${Math.random()}.${ext}`;
    }
    /**
     * Creates a new Joplin resource from the image data. The image will be
     * first converted to a JPEG.
     */
    toJpgResource(handle, resourceProps, quality = 80) {
        return __awaiter(this, void 0, void 0, function* () {
            const tempFilePath = this.tempFilePath('jpg');
            yield this.toJpgFile(handle, tempFilePath, quality);
            const newResource = yield shim_1.default.createResourceFromPath(tempFilePath, resourceProps, { resizeLargeImages: 'never' });
            yield shim_1.default.fsDriver().remove(tempFilePath);
            return newResource;
        });
    }
    /**
     * Creates a new Joplin resource from the image data. The image will be
     * first converted to a PNG.
     */
    toPngResource(handle, resourceProps) {
        return __awaiter(this, void 0, void 0, function* () {
            const tempFilePath = this.tempFilePath('png');
            yield this.toPngFile(handle, tempFilePath);
            const newResource = yield shim_1.default.createResourceFromPath(tempFilePath, resourceProps, { resizeLargeImages: 'never' });
            yield shim_1.default.fsDriver().remove(tempFilePath);
            return newResource;
        });
    }
    /**
     * Image data is not automatically deleted by Joplin so make sure you call
     * this method on the handle once you are done.
     */
    free(handle) {
        return __awaiter(this, void 0, void 0, function* () {
            const index = this.images_.findIndex(i => i.handle === handle);
            if (index >= 0)
                this.images_.splice(index, 1);
        });
    }
}
exports.default = JoplinImaging;
//# sourceMappingURL=JoplinImaging.js.map