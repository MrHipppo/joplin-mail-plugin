"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const shim_1 = require("../../shim");
const locale_1 = require("../../locale");
const BaseItem_1 = require("../../models/BaseItem");
const BaseModel_1 = require("../../BaseModel");
const Resource_1 = require("../../models/Resource");
const Folder_1 = require("../../models/Folder");
const NoteTag_1 = require("../../models/NoteTag");
const Note_1 = require("../../models/Note");
const ArrayUtils = require("../../ArrayUtils");
const InteropService_Importer_Jex_1 = require("./InteropService_Importer_Jex");
const InteropService_Importer_Md_1 = require("./InteropService_Importer_Md");
const InteropService_Importer_Md_frontmatter_1 = require("./InteropService_Importer_Md_frontmatter");
const InteropService_Importer_Raw_1 = require("./InteropService_Importer_Raw");
const InteropService_Exporter_Jex_1 = require("./InteropService_Exporter_Jex");
const InteropService_Exporter_Raw_1 = require("./InteropService_Exporter_Raw");
const InteropService_Exporter_Md_1 = require("./InteropService_Exporter_Md");
const InteropService_Exporter_Md_frontmatter_1 = require("./InteropService_Exporter_Md_frontmatter");
const InteropService_Importer_Base_1 = require("./InteropService_Importer_Base");
const InteropService_Exporter_Base_1 = require("./InteropService_Exporter_Base");
const Module_1 = require("./Module");
const { sprintf } = require('sprintf-js');
const { fileExtension } = require('../../path-utils');
const EventEmitter = require('events');
class InteropService {
    static instance() {
        if (!this.instance_)
            this.instance_ = new InteropService();
        return this.instance_;
    }
    constructor() {
        this.userModules_ = [];
        this.eventEmitter_ = null;
        this.eventEmitter_ = new EventEmitter();
    }
    // eslint-disable-next-line @typescript-eslint/ban-types -- Old code before rule was applied
    on(eventName, callback) {
        return this.eventEmitter_.on(eventName, callback);
    }
    // eslint-disable-next-line @typescript-eslint/ban-types -- Old code before rule was applied
    off(eventName, callback) {
        return this.eventEmitter_.removeListener(eventName, callback);
    }
    modules() {
        if (!this.defaultModules_) {
            const importModules = [
                (0, Module_1.makeImportModule)({
                    format: 'jex',
                    fileExtensions: ['jex'],
                    sources: [types_1.FileSystemItem.File],
                    description: (0, locale_1._)('Joplin Export File'),
                }, () => new InteropService_Importer_Jex_1.default()),
                (0, Module_1.makeImportModule)({
                    format: 'raw',
                    sources: [types_1.FileSystemItem.Directory],
                    description: (0, locale_1._)('Joplin Export Directory'),
                    separatorAfter: true,
                }, () => new InteropService_Importer_Raw_1.default()),
                (0, Module_1.makeImportModule)({
                    format: 'enex',
                    fileExtensions: ['enex'],
                    sources: [types_1.FileSystemItem.File],
                    description: (0, locale_1._)('Evernote Export File (as HTML)'),
                    supportsMobile: false,
                    outputFormat: types_1.ImportModuleOutputFormat.Html,
                }, (0, Module_1.dynamicRequireModuleFactory)('./InteropService_Importer_EnexToHtml')),
                (0, Module_1.makeImportModule)({
                    format: 'enex',
                    fileExtensions: ['enex'],
                    sources: [types_1.FileSystemItem.File],
                    description: (0, locale_1._)('Evernote Export File (as Markdown)'),
                    supportsMobile: false,
                    isDefault: true,
                }, (0, Module_1.dynamicRequireModuleFactory)('./InteropService_Importer_EnexToMd')),
                (0, Module_1.makeImportModule)({
                    format: 'html',
                    fileExtensions: ['html'],
                    sources: [types_1.FileSystemItem.File, types_1.FileSystemItem.Directory],
                    isNoteArchive: false,
                    description: (0, locale_1._)('HTML document'),
                }, () => new InteropService_Importer_Md_1.default()),
                (0, Module_1.makeImportModule)({
                    format: 'md',
                    fileExtensions: ['md', 'markdown', 'txt', 'html'],
                    sources: [types_1.FileSystemItem.File, types_1.FileSystemItem.Directory],
                    isNoteArchive: false,
                    description: (0, locale_1._)('Markdown'),
                }, () => new InteropService_Importer_Md_1.default()),
                (0, Module_1.makeImportModule)({
                    format: 'md_frontmatter',
                    fileExtensions: ['md', 'markdown', 'txt', 'html'],
                    sources: [types_1.FileSystemItem.File, types_1.FileSystemItem.Directory],
                    isNoteArchive: false,
                    description: (0, locale_1._)('Markdown + Front Matter'),
                }, () => new InteropService_Importer_Md_frontmatter_1.default()),
                (0, Module_1.makeImportModule)({
                    format: 'txt',
                    fileExtensions: ['txt'],
                    sources: [types_1.FileSystemItem.File, types_1.FileSystemItem.Directory],
                    isNoteArchive: false,
                    description: (0, locale_1._)('Text document'),
                }, () => new InteropService_Importer_Md_1.default()),
            ];
            const exportModules = [
                (0, Module_1.makeExportModule)({
                    format: 'jex',
                    fileExtensions: ['jex'],
                    target: types_1.FileSystemItem.File,
                    description: (0, locale_1._)('Joplin Export File'),
                }, () => new InteropService_Exporter_Jex_1.default()),
                (0, Module_1.makeExportModule)({
                    format: 'raw',
                    target: types_1.FileSystemItem.Directory,
                    description: (0, locale_1._)('Joplin Export Directory'),
                }, () => new InteropService_Exporter_Raw_1.default()),
                (0, Module_1.makeExportModule)({
                    format: 'md',
                    target: types_1.FileSystemItem.Directory,
                    description: (0, locale_1._)('Markdown'),
                }, () => new InteropService_Exporter_Md_1.default()),
                (0, Module_1.makeExportModule)({
                    format: 'md_frontmatter',
                    target: types_1.FileSystemItem.Directory,
                    description: (0, locale_1._)('Markdown + Front Matter'),
                }, () => new InteropService_Exporter_Md_frontmatter_1.default()),
                (0, Module_1.makeExportModule)({
                    format: 'html',
                    fileExtensions: ['html', 'htm'],
                    target: types_1.FileSystemItem.File,
                    isNoteArchive: false,
                    description: (0, locale_1._)('HTML File'),
                    supportsMobile: false,
                }, (0, Module_1.dynamicRequireModuleFactory)('./InteropService_Exporter_Html')),
                (0, Module_1.makeExportModule)({
                    format: 'html',
                    target: types_1.FileSystemItem.Directory,
                    description: (0, locale_1._)('HTML Directory'),
                    supportsMobile: false,
                }, (0, Module_1.dynamicRequireModuleFactory)('./InteropService_Exporter_Html')),
            ];
            this.defaultModules_ = importModules.concat(exportModules);
        }
        return this.defaultModules_.concat(this.userModules_);
    }
    registerModule(module) {
        this.userModules_.push(module);
        this.eventEmitter_.emit('modulesChanged');
    }
    // Find the module that matches the given type ("importer" or "exporter")
    // and the given format. Some formats can have multiple assocated importers
    // or exporters, such as ENEX. In this case, the one marked as "isDefault"
    // is returned. This is useful to auto-detect the module based on the format.
    // For more precise matching, newModuleFromPath_ should be used.
    findModuleByFormat_(type, format, target = null, outputFormat = null) {
        const modules = this.modules();
        const matches = [];
        const isMobile = shim_1.default.mobilePlatform() !== '';
        for (let i = 0; i < modules.length; i++) {
            const m = modules[i];
            if (!m.supportsMobile && isMobile) {
                continue;
            }
            if (m.format === format && m.type === type) {
                if (!target && !outputFormat) {
                    matches.push(m);
                }
                else if (m.type === types_1.ModuleType.Exporter && target && target === m.target) {
                    matches.push(m);
                }
                else if (m.type === types_1.ModuleType.Importer && outputFormat && outputFormat === m.outputFormat) {
                    matches.push(m);
                }
            }
        }
        const output = matches.find(m => !!m.isDefault);
        if (output)
            return output;
        return matches.length ? matches[0] : null;
    }
    // NOTE TO FUTURE SELF: It might make sense to simply move all the existing
    // formatters to the `newModuleFromPath_` approach, so that there's only one way
    // to do this mapping. This isn't a priority right now (per the convo in:
    // https://github.com/laurent22/joplin/pull/1795#discussion_r322379121) but
    // we can do it if it ever becomes necessary.
    newModuleByFormat_(type, format, outputFormat = types_1.ImportModuleOutputFormat.Markdown) {
        const moduleMetadata = this.findModuleByFormat_(type, format, null, outputFormat);
        if (!moduleMetadata)
            throw new Error((0, locale_1._)('Cannot load "%s" module for format "%s" and output "%s"', type, format, outputFormat));
        return moduleMetadata.factory();
    }
    // The existing `newModuleByFormat_` fn would load by the input format. This
    // was fine when there was a 1-1 mapping of input formats to output formats,
    // but now that we have 2 possible outputs for an `enex` input, we need to be
    // explicit with which importer we want to use.
    //
    // https://github.com/laurent22/joplin/pull/1795#pullrequestreview-281574417
    newModuleFromPath_(type, options) {
        const moduleMetadata = this.findModuleByFormat_(type, options.format, options.target);
        if (!moduleMetadata)
            throw new Error((0, locale_1._)('Cannot load "%s" module for format "%s" and target "%s"', type, options.format, options.target));
        return moduleMetadata.factory(options);
    }
    moduleByFileExtension_(type, ext) {
        ext = ext.toLowerCase();
        const modules = this.modules();
        for (let i = 0; i < modules.length; i++) {
            const m = modules[i];
            if (type !== m.type)
                continue;
            if (m.fileExtensions.includes(ext))
                return m;
        }
        return null;
    }
    import(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield shim_1.default.fsDriver().exists(options.path)))
                throw new Error((0, locale_1._)('Cannot find "%s".', options.path));
            options = Object.assign({ format: 'auto', destinationFolderId: null, destinationFolder: null }, options);
            if (options.format === 'auto') {
                const module = this.moduleByFileExtension_(types_1.ModuleType.Importer, fileExtension(options.path));
                if (!module)
                    throw new Error((0, locale_1._)('Please specify import format for %s', options.path));
                options.format = module.format;
            }
            if (options.destinationFolderId) {
                const folder = yield Folder_1.default.load(options.destinationFolderId);
                if (!folder)
                    throw new Error((0, locale_1._)('Cannot find "%s".', options.destinationFolderId));
                options.destinationFolder = folder;
            }
            let result = { warnings: [] };
            const importer = this.newModuleByFormat_(types_1.ModuleType.Importer, options.format, options.outputFormat);
            if (!(importer instanceof InteropService_Importer_Base_1.default)) {
                throw new Error('Resolved importer is not an importer');
            }
            yield importer.init(options.path, options);
            result = yield importer.exec(result);
            return result;
        });
    }
    normalizeItemForExport(_itemType, item) {
        const override = {};
        if ('is_shared' in item)
            override.is_shared = 0;
        if ('share_id' in item)
            override.share_id = '';
        if (Object.keys(override).length) {
            return Object.assign(Object.assign({}, item), override);
        }
        else {
            return item;
        }
    }
    export(options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            options = Object.assign({ format: 'jex' }, options);
            const exportPath = options.path ? options.path : null;
            let sourceFolderIds = options.sourceFolderIds ? options.sourceFolderIds : [];
            const sourceNoteIds = options.sourceNoteIds ? options.sourceNoteIds : [];
            const result = { warnings: [] };
            const itemsToExport = [];
            (_a = options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, types_1.ExportProgressState.QueuingItems, null);
            let totalItemsToProcess = 0;
            const queueExportItem = (itemType, itemOrId) => {
                totalItemsToProcess++;
                itemsToExport.push({
                    type: itemType,
                    itemOrId: itemOrId,
                });
            };
            const exportedNoteIds = [];
            let resourceIds = [];
            // Recursively get all the folders that have valid parents
            const folderIds = yield Folder_1.default.childrenIds('');
            if (options.includeConflicts)
                folderIds.push(Folder_1.default.conflictFolderId());
            let fullSourceFolderIds = sourceFolderIds.slice();
            for (let i = 0; i < sourceFolderIds.length; i++) {
                const id = sourceFolderIds[i];
                const childrenIds = yield Folder_1.default.childrenIds(id);
                fullSourceFolderIds = fullSourceFolderIds.concat(childrenIds);
            }
            sourceFolderIds = fullSourceFolderIds;
            for (let folderIndex = 0; folderIndex < folderIds.length; folderIndex++) {
                const folderId = folderIds[folderIndex];
                if (sourceFolderIds.length && sourceFolderIds.indexOf(folderId) < 0)
                    continue;
                if (!sourceNoteIds.length)
                    yield queueExportItem(BaseModel_1.default.TYPE_FOLDER, folderId);
                const noteIds = yield Folder_1.default.noteIds(folderId, { includeConflicts: !!options.includeConflicts });
                for (let noteIndex = 0; noteIndex < noteIds.length; noteIndex++) {
                    const noteId = noteIds[noteIndex];
                    if (sourceNoteIds.length && sourceNoteIds.indexOf(noteId) < 0)
                        continue;
                    const note = yield Note_1.default.load(noteId);
                    yield queueExportItem(BaseModel_1.default.TYPE_NOTE, note);
                    exportedNoteIds.push(noteId);
                    const rids = yield Note_1.default.linkedResourceIds(note.body);
                    resourceIds = resourceIds.concat(rids);
                }
            }
            resourceIds = ArrayUtils.unique(resourceIds);
            for (let i = 0; i < resourceIds.length; i++) {
                yield queueExportItem(BaseModel_1.default.TYPE_RESOURCE, resourceIds[i]);
            }
            const noteTags = yield NoteTag_1.default.all();
            const exportedTagIds = [];
            for (let i = 0; i < noteTags.length; i++) {
                const noteTag = noteTags[i];
                if (exportedNoteIds.indexOf(noteTag.note_id) < 0)
                    continue;
                yield queueExportItem(BaseModel_1.default.TYPE_NOTE_TAG, noteTag.id);
                exportedTagIds.push(noteTag.tag_id);
            }
            for (let i = 0; i < exportedTagIds.length; i++) {
                yield queueExportItem(BaseModel_1.default.TYPE_TAG, exportedTagIds[i]);
            }
            const exporter = this.newModuleFromPath_(types_1.ModuleType.Exporter, options);
            if (!(exporter instanceof InteropService_Exporter_Base_1.default)) {
                throw new Error('Resolved exporter is not an exporter');
            }
            yield exporter.init(exportPath, options);
            const typeOrder = [BaseModel_1.default.TYPE_FOLDER, BaseModel_1.default.TYPE_RESOURCE, BaseModel_1.default.TYPE_NOTE, BaseModel_1.default.TYPE_TAG, BaseModel_1.default.TYPE_NOTE_TAG];
            const context = {
                resourcePaths: {},
            };
            // Prepare to process each type before starting any
            // This will allow exporters to operate on the full context
            for (let typeOrderIndex = 0; typeOrderIndex < typeOrder.length; typeOrderIndex++) {
                const type = typeOrder[typeOrderIndex];
                yield exporter.prepareForProcessingItemType(type, itemsToExport);
            }
            let itemsProcessed = 0;
            for (let typeOrderIndex = 0; typeOrderIndex < typeOrder.length; typeOrderIndex++) {
                const type = typeOrder[typeOrderIndex];
                for (let i = 0; i < itemsToExport.length; i++) {
                    const itemType = itemsToExport[i].type;
                    if (itemType !== type)
                        continue;
                    const ItemClass = BaseItem_1.default.getClassByItemType(itemType);
                    const itemOrId = itemsToExport[i].itemOrId;
                    const rawItem = typeof itemOrId === 'object' ? itemOrId : yield ItemClass.load(itemOrId);
                    if (!rawItem) {
                        if (itemType === BaseModel_1.default.TYPE_RESOURCE) {
                            result.warnings.push(sprintf('A resource that does not exist is referenced in a note. The resource was skipped. Resource ID: %s', itemOrId));
                        }
                        else {
                            result.warnings.push(sprintf('Cannot find item with type "%s" and ID %s. Item was skipped.', ItemClass.tableName(), JSON.stringify(itemOrId)));
                        }
                        continue;
                    }
                    const item = this.normalizeItemForExport(itemType, rawItem);
                    if (item.encryption_applied || item.encryption_blob_encrypted) {
                        result.warnings.push(sprintf('This item is currently encrypted: %s "%s" (%s) and was not exported. You may wait for it to be decrypted and try again.', BaseModel_1.default.modelTypeToName(itemType), item.title ? item.title : item.id, item.id));
                        continue;
                    }
                    try {
                        if (itemType === BaseModel_1.default.TYPE_RESOURCE) {
                            const resourcePath = Resource_1.default.fullPath(item);
                            context.resourcePaths[item.id] = resourcePath;
                            exporter.updateContext(context);
                            yield exporter.processResource(item, resourcePath);
                        }
                        yield exporter.processItem(itemType, item);
                    }
                    catch (error) {
                        console.error(error);
                        result.warnings.push(error.message);
                    }
                    itemsProcessed++;
                    (_b = options.onProgress) === null || _b === void 0 ? void 0 : _b.call(options, types_1.ExportProgressState.Exporting, itemsProcessed / totalItemsToProcess);
                }
            }
            (_c = options.onProgress) === null || _c === void 0 ? void 0 : _c.call(options, types_1.ExportProgressState.Closing, null);
            yield exporter.close();
            return result;
        });
    }
}
exports.default = InteropService;
//# sourceMappingURL=InteropService.js.map