"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Note_1 = require("../../models/Note");
const Tag_1 = require("../../models/Tag");
const time_1 = require("../../time");
const test_utils_1 = require("../../testing/test-utils");
const types_1 = require("./types");
const InteropService_1 = require("./InteropService");
const Folder_1 = require("../../models/Folder");
function importNote(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const folder = yield Folder_1.default.save({});
        const importOptions = {
            path: path,
            format: 'md_frontmatter',
            destinationFolderId: folder.id,
            outputFormat: types_1.ImportModuleOutputFormat.Markdown,
        };
        yield InteropService_1.default.instance().import(importOptions);
        const allNotes = yield Note_1.default.all();
        return allNotes[0];
    });
}
const importTestFile = (name) => __awaiter(void 0, void 0, void 0, function* () {
    return importNote(`${test_utils_1.supportDir}/test_notes/yaml/${name}`);
});
describe('InteropService_Importer_Md_frontmatter: importMetadata', () => {
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
    }));
    it('should import file and set all metadata correctly', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('full.md');
        const format = 'DD/MM/YYYY HH:mm';
        expect(note.title).toBe('Test Note Title');
        expect(time_1.default.formatMsToLocal(note.user_updated_time, format)).toBe('01/05/2019 16:54');
        expect(time_1.default.formatMsToLocal(note.user_created_time, format)).toBe('01/05/2019 16:54');
        expect(note.source_url).toBe('https://joplinapp.org');
        expect(note.author).toBe('Joplin');
        expect(note.latitude).toBe('37.08402100');
        expect(note.longitude).toBe('-94.51350100');
        expect(note.altitude).toBe('0.0000');
        expect(note.is_todo).toBe(1);
        expect(note.todo_completed).toBe(0);
        expect(time_1.default.formatMsToLocal(note.todo_due, format)).toBe('22/08/2021 00:00');
        expect(note.body).toBe('This is the note body\n');
        const tags = yield Tag_1.default.tagsByNoteId(note.id);
        expect(tags.length).toBe(3);
        const tagTitles = tags.map(tag => tag.title);
        expect(tagTitles).toContain('joplin');
        expect(tagTitles).toContain('note');
        expect(tagTitles).toContain('pencil');
    }));
    it('should only import data from the first yaml block', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('split.md');
        expect(note.title).toBe('xxx');
        expect(note.author).not.toBe('xxx');
        expect(note.body).toBe('---\nauthor: xxx\n---\n\nnote body\n');
    }));
    it('should only import, duplicate notes and tags are not created', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('duplicates.md');
        expect(note.title).toBe('ddd');
        const itemIds = yield Note_1.default.linkedItemIds(note.body);
        expect(itemIds.length).toBe(1);
        const tags = yield Tag_1.default.tagsByNoteId(note.id);
        expect(tags.length).toBe(1);
    }));
    it('should not import items as numbers', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('numbers.md');
        expect(note.title).toBe('001');
        expect(note.body).toBe('note body\n');
    }));
    it('should normalize whitespace and load correctly', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('normalize.md');
        expect(note.title).toBe('norm');
        expect(note.body).toBe('note body\n');
        const tags = yield Tag_1.default.tagsByNoteId(note.id);
        expect(tags.length).toBe(3);
    }));
    it('should load unquoted special forms correctly', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('unquoted.md');
        expect(note.title).toBe('Unquoted');
        expect(note.body).toBe('note body\n');
        expect(note.longitude).toBe('-94.51350100');
        expect(note.is_todo).toBe(1);
        expect(note.todo_completed).toBe(0);
    }));
    it('should load notes with newline in the title', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('title_newline.md');
        expect(note.title).toBe('First\nSecond');
    }));
    it('should import dates (without time) correctly', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('short_date.md');
        const format = 'YYYY-MM-DD HH:mm';
        expect(time_1.default.formatMsToLocal(note.user_updated_time, format)).toBe('2021-01-01 00:00');
        expect(time_1.default.formatMsToLocal(note.user_created_time, format)).toBe('2017-01-01 00:00');
    }));
    it('should load tags even with the inline syntax', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('inline_tags.md');
        expect(note.title).toBe('Inline Tags');
        const tags = yield Tag_1.default.tagsByNoteId(note.id);
        expect(tags.length).toBe(2);
    }));
    it('should import r-markdown files correctly and set what metadata it can', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('r-markdown.md');
        const format = 'YYYY-MM-DD HH:mm';
        expect(note.title).toBe('YAML metadata for R Markdown with examples');
        expect(time_1.default.formatMsToLocal(note.user_updated_time, format)).toBe('2021-06-10 00:00');
        expect(time_1.default.formatMsToLocal(note.user_created_time, format)).toBe('2021-06-10 00:00');
        expect(note.author).toBe('Hao Liang');
        const tags = yield Tag_1.default.tagsByNoteId(note.id);
        expect(tags.length).toBe(2);
        const tagTitles = tags.map(tag => tag.title);
        expect(tagTitles).toContain('yaml');
        expect(tagTitles).toContain('rmd');
    }));
    it('should import r-markdown files with alternative author syntax', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('r-markdown_author.md');
        expect(note.title).toBe('Distill for R Markdown');
        expect(note.author).toBe('JJ Allaire');
    }));
    it('should handle date formats with timezone information', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('utc.md');
        expect(note.user_updated_time).toBe(1556729640000);
        expect(note.user_created_time).toBe(1556754840000);
    }));
    it('should accept file with no newline after the block marker', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('no_newline_after_marker.md');
        expect(note.body).toBe('note body\n');
    }));
    it('should handle multiple newlines before the note body', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importTestFile('multiple_newlines_after_marker.md');
        expect(note.body).toBe('\n\nnote body');
    }));
});
//# sourceMappingURL=InteropService_Importer_Md_frontmatter.test.js.map