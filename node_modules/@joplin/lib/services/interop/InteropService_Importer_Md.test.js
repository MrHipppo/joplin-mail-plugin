"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const InteropService_Importer_Md_1 = require("../../services/interop/InteropService_Importer_Md");
const Note_1 = require("../../models/Note");
const Folder_1 = require("../../models/Folder");
const fs = require("fs-extra");
const test_utils_1 = require("../../testing/test-utils");
const renderer_1 = require("@joplin/renderer");
describe('InteropService_Importer_Md', () => {
    let tempDir;
    function importNote(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const newFolder = yield Folder_1.default.save({ title: 'folder' });
            const importer = new InteropService_Importer_Md_1.default();
            yield importer.init(path, {
                format: 'md',
                outputFormat: 'md',
                path,
                destinationFolder: newFolder,
                destinationFolderId: newFolder.id,
            });
            importer.setMetadata({ fileExtensions: ['md'] });
            yield importer.exec({ warnings: [] });
            const allNotes = yield Note_1.default.all();
            return allNotes[0];
        });
    }
    function importNoteDirectory(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const importer = new InteropService_Importer_Md_1.default();
            yield importer.init(path, {
                format: 'md',
                outputFormat: 'md',
                path,
            });
            importer.setMetadata({ fileExtensions: ['md', 'html'] });
            return yield importer.exec({ warnings: [] });
        });
    }
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        tempDir = yield (0, test_utils_1.createTempDir)();
    }));
    afterEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield fs.remove(tempDir);
    }));
    it('should import linked files and modify tags appropriately', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample.md`);
        const tagNonExistentFile = '![does not exist](does_not_exist.png)';
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(2);
        const inexistentLinkUnchanged = note.body.includes(tagNonExistentFile);
        expect(inexistentLinkUnchanged).toBe(true);
    }));
    it('should only create 1 resource for duplicate links, all tags should be updated', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-duplicate-links.md`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(1);
        const reg = new RegExp(items[0].id, 'g');
        const matched = note.body.match(reg);
        expect(matched.length).toBe(2);
    }));
    it('should import linked files and modify tags appropriately when link is also in alt text', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-link-in-alt-text.md`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(1);
    }));
    it('should passthrough unchanged if no links present', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-no-links.md`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(0);
        expect(note.body).toContain('Unidentified vessel travelling at sub warp speed, bearing 235.7. Fluctuations in energy readings from it, Captain. All transporters off.');
    }));
    it('should import linked image with special characters in name', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-special-chars.md`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(3);
        const noteIds = yield Note_1.default.linkedNoteIds(note.body);
        expect(noteIds.length).toBe(1);
        const spaceSyntaxLeft = note.body.includes('<../../photo sample.jpg>');
        expect(spaceSyntaxLeft).toBe(false);
    }));
    it('should import resources and notes for files', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-files.md`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(3);
        const noteIds = yield Note_1.default.linkedNoteIds(note.body);
        expect(noteIds.length).toBe(1);
    }));
    it('should gracefully handle reference cycles in notes', () => __awaiter(void 0, void 0, void 0, function* () {
        yield importNoteDirectory(`${test_utils_1.supportDir}/test_notes/md/cycle-reference`);
        const [noteA, noteB] = yield Note_1.default.all();
        const noteAIds = yield Note_1.default.linkedNoteIds(noteA.body);
        expect(noteAIds.length).toBe(1);
        const noteBIds = yield Note_1.default.linkedNoteIds(noteB.body);
        expect(noteBIds.length).toBe(1);
        expect(noteAIds[0]).toEqual(noteB.id);
        expect(noteBIds[0]).toEqual(noteA.id);
    }));
    it('should not import resources from file:// links', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-file-links.md`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(0);
        expect(note.body).toContain('![sample](file://../../photo.jpg)');
    }));
    it('should attach resources that are missing the file extension', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-no-extension.md`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(1);
    }));
    it('should attach resources that include anchor links', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-anchor-link.md`);
        const itemIds = yield Note_1.default.linkedItemIds(note.body);
        expect(itemIds.length).toBe(1);
        expect(note.body).toContain(`[Section 1](:/${itemIds[0]}#markdown)`);
    }));
    it('should attach resources that include a title', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample-link-title.md`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(3);
        const noteIds = yield Note_1.default.linkedNoteIds(note.body);
        expect(noteIds.length).toBe(1);
    }));
    it('should import notes with html file extension as html', () => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield importNote(`${test_utils_1.supportDir}/test_notes/md/sample.html`);
        const items = yield Note_1.default.linkedItems(note.body);
        expect(items.length).toBe(3);
        const noteIds = yield Note_1.default.linkedNoteIds(note.body);
        expect(noteIds.length).toBe(1);
        expect(note.markup_language).toBe(renderer_1.MarkupToHtml.MARKUP_LANGUAGE_HTML);
        const preservedAlt = note.body.includes('alt="../../photo.jpg"');
        expect(preservedAlt).toBe(true);
    }));
    it('should import non-empty directory', () => __awaiter(void 0, void 0, void 0, function* () {
        yield fs.mkdirp(`${tempDir}/non-empty/non-empty`);
        yield fs.writeFile(`${tempDir}/non-empty/non-empty/sample.md`, '# Sample');
        yield importNoteDirectory(`${tempDir}/non-empty`);
        const allFolders = yield Folder_1.default.all();
        expect(allFolders.map((f) => f.title).indexOf('non-empty')).toBeGreaterThanOrEqual(0);
    }));
    it('should not import empty directory', () => __awaiter(void 0, void 0, void 0, function* () {
        yield fs.mkdirp(`${tempDir}/empty1/empty2`);
        yield importNoteDirectory(`${tempDir}/empty1`);
        const allFolders = yield Folder_1.default.all();
        expect(allFolders.map((f) => f.title).indexOf('empty1')).toBe(0);
        expect(allFolders.map((f) => f.title).indexOf('empty2')).toBe(-1);
    }));
    it('should import directory with non-empty subdirectory', () => __awaiter(void 0, void 0, void 0, function* () {
        yield fs.mkdirp(`${tempDir}/non-empty-subdir/non-empty-subdir/subdir-empty`);
        yield fs.mkdirp(`${tempDir}/non-empty-subdir/non-empty-subdir/subdir-non-empty`);
        yield fs.writeFile(`${tempDir}/non-empty-subdir/non-empty-subdir/subdir-non-empty/sample.md`, '# Sample');
        yield importNoteDirectory(`${tempDir}/non-empty-subdir`);
        const allFolders = yield Folder_1.default.all();
        expect(allFolders.map((f) => f.title).indexOf('non-empty-subdir')).toBeGreaterThanOrEqual(0);
        expect(allFolders.map((f) => f.title).indexOf('subdir-empty')).toBe(-1);
        expect(allFolders.map((f) => f.title).indexOf('subdir-non-empty')).toBeGreaterThanOrEqual(0);
    }));
    it('should import all files before replacing links', () => __awaiter(void 0, void 0, void 0, function* () {
        yield fs.mkdirp(`${tempDir}/links/0/1/2`);
        yield fs.mkdirp(`${tempDir}/links/Target_folder`);
        yield fs.writeFile(`${tempDir}/links/Target_folder/Targeted_note.md`, '# Targeted_note');
        yield fs.writeFile(`${tempDir}/links/0/1/2/Note_with_reference_to_another_note.md`, '# 20\n[Target_folder:Targeted_note](../../../Target_folder/Targeted_note.md)');
        yield importNoteDirectory(`${tempDir}/links`);
        const allFolders = yield Folder_1.default.all();
        const allNotes = yield Note_1.default.all();
        const targetFolder = allFolders.find(f => f.title === 'Target_folder');
        const noteBeingReferenced = allNotes.find(n => n.title === 'Targeted_note');
        expect(noteBeingReferenced.parent_id).toBe(targetFolder.id);
    }));
});
//# sourceMappingURL=InteropService_Importer_Md.test.js.map