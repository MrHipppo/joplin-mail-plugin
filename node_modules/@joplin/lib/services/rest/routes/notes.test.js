"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("@joplin/utils/Logger");
const shim_1 = require("../../../shim");
const uuid_1 = require("../../../uuid");
const notes_1 = require("./notes");
describe('routes/notes', () => {
    beforeEach(() => {
        jest.resetAllMocks();
    });
    test.each([
        '/invalid/url',
        'htp/asdfasf.com',
        'https//joplinapp.org',
    ])('should not return a local file for invalid protocols', (invalidUrl) => __awaiter(void 0, void 0, void 0, function* () {
        yield expect((0, notes_1.downloadMediaFile)(invalidUrl)).resolves.toBe('');
    }));
    test.each([
        'https://joplinapp.org/valid/image_url.png',
        'http://joplinapp.org/valid/image_url.png',
    ])('should try to download and return a local path to a valid URL', (url) => __awaiter(void 0, void 0, void 0, function* () {
        const fetchBlobSpy = jest.fn();
        jest.spyOn(shim_1.default, 'fetchBlob').mockImplementation(fetchBlobSpy);
        jest.spyOn(uuid_1.default, 'create').mockReturnValue('mocked_uuid_value');
        const response = yield (0, notes_1.downloadMediaFile)(url);
        expect(response.endsWith('mocked_uuid_value.png')).toBe(true);
        expect(fetchBlobSpy).toBeCalledTimes(1);
    }));
    test('should get file from local drive if protocol allows it', () => __awaiter(void 0, void 0, void 0, function* () {
        const url = 'file://valid/image.png';
        const fsDriverCopySpy = jest.fn();
        jest.spyOn(shim_1.default, 'fsDriver').mockImplementation(() => {
            return {
                copy: fsDriverCopySpy,
            };
        });
        jest.spyOn(uuid_1.default, 'create').mockReturnValue('mocked_uuid_value');
        const response = yield (0, notes_1.downloadMediaFile)(url);
        expect(response.endsWith('mocked_uuid_value.png')).toBe(true);
        expect(fsDriverCopySpy).toBeCalledTimes(1);
    }));
    test('should be able to handle URLs with data', () => __awaiter(void 0, void 0, void 0, function* () {
        const url = 'data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7';
        const imageFromDataUrlSpy = jest.fn();
        jest.spyOn(shim_1.default, 'imageFromDataUrl').mockImplementation(imageFromDataUrlSpy);
        jest.spyOn(uuid_1.default, 'create').mockReturnValue('mocked_uuid_value');
        const response = yield (0, notes_1.downloadMediaFile)(url);
        expect(response.endsWith('mocked_uuid_value.gif')).toBe(true);
        expect(imageFromDataUrlSpy).toBeCalledTimes(1);
    }));
    test('should not process URLs with data that is not image type', () => __awaiter(void 0, void 0, void 0, function* () {
        const url = 'data:application/octet-stream;base64,dGhpcyBpcyBhIG1lc3NhZ2UK';
        Logger_1.default.globalLogger.enabled = false;
        const response = yield (0, notes_1.downloadMediaFile)(url);
        Logger_1.default.globalLogger.enabled = true;
        expect(response).toBe('');
    }));
    test('should not process URLs from cid: protocol', () => __awaiter(void 0, void 0, void 0, function* () {
        const url = 'cid:ii_loq3d1100';
        const response = yield (0, notes_1.downloadMediaFile)(url);
        expect(response).toBe('');
    }));
});
//# sourceMappingURL=notes.test.js.map