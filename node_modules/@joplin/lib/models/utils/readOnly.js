"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.itemIsReadOnly = exports.itemIsReadOnlySync = exports.checkIfItemCanBeAddedToFolder = exports.checkIfItemCanBeChanged = exports.checkIfItemsCanBeChanged = exports.needsReadOnlyChecks = void 0;
const Logger_1 = require("@joplin/utils/Logger");
const BaseModel_1 = require("../../BaseModel");
const errors_1 = require("../../errors");
const JoplinError_1 = require("../../JoplinError");
const ItemChange_1 = require("../ItemChange");
const Setting_1 = require("../Setting");
const logger = Logger_1.default.create('models/utils/readOnly');
// This function can be called to wrap any read-only-related code. It should be
// fast and allows an early exit for cases that don't apply, for example if not
// synchronising with Joplin Cloud or if not sharing any notebook.
const needsReadOnlyChecks = (itemType, changeSource, shareState, disableReadOnlyCheck = false) => {
    if (disableReadOnlyCheck)
        return false;
    if (Setting_1.default.value('sync.target') !== 10)
        return false;
    if (changeSource === ItemChange_1.default.SOURCE_SYNC)
        return false;
    if (!Setting_1.default.value('sync.userId'))
        return false;
    if (![BaseModel_1.ModelType.Note, BaseModel_1.ModelType.Folder, BaseModel_1.ModelType.Resource].includes(itemType))
        return false;
    if (!shareState)
        throw new Error('Share state must be provided');
    if (!shareState.shareInvitations.length)
        return false;
    return true;
};
exports.needsReadOnlyChecks = needsReadOnlyChecks;
const checkIfItemsCanBeChanged = (itemType, changeSource, items, shareState) => {
    for (const item of items) {
        (0, exports.checkIfItemCanBeChanged)(itemType, changeSource, item, shareState);
    }
};
exports.checkIfItemsCanBeChanged = checkIfItemsCanBeChanged;
const checkIfItemCanBeChanged = (itemType, changeSource, item, shareState) => {
    if (!(0, exports.needsReadOnlyChecks)(itemType, changeSource, shareState))
        return;
    if (!item)
        return;
    if ((0, exports.itemIsReadOnlySync)(itemType, changeSource, item, Setting_1.default.value('sync.userId'), shareState)) {
        throw new JoplinError_1.default(`Cannot change or delete a read-only item: ${item.id}`, errors_1.ErrorCode.IsReadOnly);
    }
};
exports.checkIfItemCanBeChanged = checkIfItemCanBeChanged;
const checkIfItemCanBeAddedToFolder = (itemType, Folder, changeSource, shareState, parentId) => __awaiter(void 0, void 0, void 0, function* () {
    if ((0, exports.needsReadOnlyChecks)(itemType, changeSource, shareState) && parentId) {
        const parentFolder = yield Folder.load(parentId, { fields: ['id', 'share_id'] });
        if (!parentFolder) {
            // Historically it's always been possible to set the parent_id of a
            // note to a folder that does not exist - this is to support
            // synchronisation, where items are downloaded in random order. It
            // is not ideal to skip the check here, but if for some reason the
            // folder turns out to be read-only the issue will be resolved
            // during sync.
            logger.warn('checkIfItemCanBeAddedToFolder: Trying to add an item to a folder that does not exist - skipping check');
            return;
        }
        if ((0, exports.itemIsReadOnlySync)(itemType, changeSource, parentFolder, Setting_1.default.value('sync.userId'), shareState)) {
            throw new JoplinError_1.default('Cannot add an item as a child of a read-only item', errors_1.ErrorCode.IsReadOnly);
        }
    }
});
exports.checkIfItemCanBeAddedToFolder = checkIfItemCanBeAddedToFolder;
const itemIsReadOnlySync = (itemType, changeSource, item, userId, shareState) => {
    if (!(0, exports.needsReadOnlyChecks)(itemType, changeSource, shareState))
        return false;
    if (!('share_id' in item))
        throw new Error('share_id property is missing');
    // Item is not shared
    if (!item.share_id)
        return false;
    // Item belongs to the user
    if (shareState.shares.find(s => s.user.id === userId))
        return false;
    const shareUser = shareState.shareInvitations.find(si => si.share.id === item.share_id);
    // Shouldn't happen
    if (!shareUser)
        return false;
    return !shareUser.can_write;
};
exports.itemIsReadOnlySync = itemIsReadOnlySync;
const itemIsReadOnly = (BaseItem, itemType, changeSource, itemId, userId, shareState) => __awaiter(void 0, void 0, void 0, function* () {
    if (!(0, exports.needsReadOnlyChecks)(itemType, changeSource, shareState))
        return false;
    const item = yield BaseItem.loadItem(itemType, itemId, { fields: ['id', 'share_id'] });
    if (!item)
        throw new JoplinError_1.default(`No such item: ${itemType}: ${itemId}`, errors_1.ErrorCode.NotFound);
    return (0, exports.itemIsReadOnlySync)(itemType, changeSource, item, userId, shareState);
});
exports.itemIsReadOnly = itemIsReadOnly;
//# sourceMappingURL=readOnly.js.map