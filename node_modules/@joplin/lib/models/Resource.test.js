"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_utils_1 = require("../testing/test-utils");
const Folder_1 = require("../models/Folder");
const Note_1 = require("../models/Note");
const Resource_1 = require("../models/Resource");
const shim_1 = require("../shim");
const errors_1 = require("../errors");
const fs_extra_1 = require("fs-extra");
const testImagePath = `${test_utils_1.supportDir}/photo.jpg`;
const setupFolderNoteResourceReadOnly = (shareId) => __awaiter(void 0, void 0, void 0, function* () {
    const cleanup = (0, test_utils_1.simulateReadOnlyShareEnv)(shareId);
    let folder = yield Folder_1.default.save({});
    let note = yield Note_1.default.save({ parent_id: folder.id });
    yield shim_1.default.attachFileToNote(note, testImagePath);
    let resource = (yield Resource_1.default.all())[0];
    folder = yield Folder_1.default.save({ id: folder.id, share_id: shareId });
    note = yield Note_1.default.save({ id: note.id, share_id: shareId });
    resource = yield Resource_1.default.save({ id: resource.id, share_id: shareId });
    resource = yield Resource_1.default.load(resource.id); // reload to get all properties
    return { cleanup, folder, note, resource };
});
describe('models/Resource', () => {
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
    }));
    it('should have a "done" fetch_status when created locally', (() => __awaiter(void 0, void 0, void 0, function* () {
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, testImagePath);
        const resource1 = (yield Resource_1.default.all())[0];
        const ls = yield Resource_1.default.localState(resource1);
        expect(ls.fetch_status).toBe(Resource_1.default.FETCH_STATUS_DONE);
    })));
    it('should have a default local state', (() => __awaiter(void 0, void 0, void 0, function* () {
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, testImagePath);
        const resource1 = (yield Resource_1.default.all())[0];
        const ls = yield Resource_1.default.localState(resource1);
        expect(!ls.id).toBe(true);
        expect(ls.resource_id).toBe(resource1.id);
        expect(ls.fetch_status).toBe(Resource_1.default.FETCH_STATUS_DONE);
    })));
    it('should save and delete local state', (() => __awaiter(void 0, void 0, void 0, function* () {
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, testImagePath);
        const resource1 = (yield Resource_1.default.all())[0];
        yield Resource_1.default.setLocalState(resource1, { fetch_status: Resource_1.default.FETCH_STATUS_IDLE });
        let ls = yield Resource_1.default.localState(resource1);
        expect(!!ls.id).toBe(true);
        expect(ls.fetch_status).toBe(Resource_1.default.FETCH_STATUS_IDLE);
        yield Resource_1.default.delete(resource1.id);
        ls = yield Resource_1.default.localState(resource1);
        expect(!ls.id).toBe(true);
    })));
    it('should resize the resource if the image is below the required dimensions', (() => __awaiter(void 0, void 0, void 0, function* () {
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        const previousMax = Resource_1.default.IMAGE_MAX_DIMENSION;
        Resource_1.default.IMAGE_MAX_DIMENSION = 5;
        yield shim_1.default.attachFileToNote(note1, testImagePath);
        Resource_1.default.IMAGE_MAX_DIMENSION = previousMax;
        const resource1 = (yield Resource_1.default.all())[0];
        const originalStat = yield shim_1.default.fsDriver().stat(testImagePath);
        const newStat = yield shim_1.default.fsDriver().stat(Resource_1.default.fullPath(resource1));
        expect(newStat.size < originalStat.size).toBe(true);
    })));
    it('should not resize the resource if the image is below the required dimensions', (() => __awaiter(void 0, void 0, void 0, function* () {
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, testImagePath);
        const resource1 = (yield Resource_1.default.all())[0];
        const originalStat = yield shim_1.default.fsDriver().stat(testImagePath);
        const newStat = yield shim_1.default.fsDriver().stat(Resource_1.default.fullPath(resource1));
        expect(originalStat.size).toBe(newStat.size);
    })));
    it('should set the blob_updated_time property if the blob is updated', (() => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield Note_1.default.save({});
        yield shim_1.default.attachFileToNote(note, testImagePath);
        const resourceA = (yield Resource_1.default.all())[0];
        expect(resourceA.updated_time).toBe(resourceA.blob_updated_time);
        yield (0, test_utils_1.msleep)(1);
        yield Resource_1.default.updateResourceBlobContent(resourceA.id, testImagePath);
        const resourceB = (yield Resource_1.default.all())[0];
        expect(resourceB.updated_time).toBeGreaterThan(resourceA.updated_time);
        expect(resourceB.blob_updated_time).toBeGreaterThan(resourceA.blob_updated_time);
    })));
    it('should NOT set the blob_updated_time property if the blob is NOT updated', (() => __awaiter(void 0, void 0, void 0, function* () {
        const note = yield Note_1.default.save({});
        yield shim_1.default.attachFileToNote(note, testImagePath);
        const resourceA = (yield Resource_1.default.all())[0];
        yield (0, test_utils_1.msleep)(1);
        // We only update the resource metadata - so the blob timestamp should
        // not change
        yield Resource_1.default.save({ id: resourceA.id, title: 'new title' });
        const resourceB = (yield Resource_1.default.all())[0];
        expect(resourceB.updated_time).toBeGreaterThan(resourceA.updated_time);
        expect(resourceB.blob_updated_time).toBe(resourceA.blob_updated_time);
    })));
    it('should not allow modifying a read-only resource', () => __awaiter(void 0, void 0, void 0, function* () {
        const { cleanup, resource } = yield setupFolderNoteResourceReadOnly('123456789');
        yield (0, test_utils_1.expectThrow)(() => __awaiter(void 0, void 0, void 0, function* () { return Resource_1.default.save({ id: resource.id, share_id: '123456789', title: 'cannot do this!' }); }), errors_1.ErrorCode.IsReadOnly);
        cleanup();
    }));
    it('should not allow modifying a read-only resource content', () => __awaiter(void 0, void 0, void 0, function* () {
        const { cleanup, resource } = yield setupFolderNoteResourceReadOnly('123456789');
        const tempFilePath = yield (0, test_utils_1.createTempFile)('something');
        yield (0, test_utils_1.expectThrow)(() => __awaiter(void 0, void 0, void 0, function* () { return Resource_1.default.updateResourceBlobContent(resource.id, tempFilePath); }), errors_1.ErrorCode.IsReadOnly);
        yield (0, fs_extra_1.remove)(tempFilePath);
        cleanup();
    }));
    it('should not allow deleting a read-only resource', () => __awaiter(void 0, void 0, void 0, function* () {
        const { cleanup, resource } = yield setupFolderNoteResourceReadOnly('123456789');
        expect(yield (0, fs_extra_1.pathExists)(Resource_1.default.fullPath(resource))).toBe(true);
        yield (0, test_utils_1.expectThrow)(() => __awaiter(void 0, void 0, void 0, function* () { return Resource_1.default.delete(resource.id); }), errors_1.ErrorCode.IsReadOnly);
        // Also check that the resource blob has not been deleted
        expect(yield (0, fs_extra_1.pathExists)(Resource_1.default.fullPath(resource))).toBe(true);
        cleanup();
    }));
});
//# sourceMappingURL=Resource.test.js.map