"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Setting_1 = require("../../models/Setting");
const Tag_1 = require("../../models/Tag");
const BaseModel_1 = require("../../BaseModel");
const Note_1 = require("../../models/Note");
const registry_js_1 = require("../../registry.js");
const ResourceFetcher_1 = require("../../services/ResourceFetcher");
const DecryptionWorker_1 = require("../../services/DecryptionWorker");
const eventManager_1 = require("../../eventManager");
const BaseItem_1 = require("../../models/BaseItem");
const reduxSharedMiddleware = function (store, _next, action) {
    return __awaiter(this, void 0, void 0, function* () {
        const newState = store.getState();
        eventManager_1.default.appStateEmit(newState);
        let refreshTags = false;
        if (action.type === 'FOLDER_SET_COLLAPSED' || action.type === 'FOLDER_TOGGLE') {
            Setting_1.default.setValue('collapsedFolderIds', newState.collapsedFolderIds);
        }
        if (action.type === 'SETTING_UPDATE_ONE' && !!action.key.match(/^sync\.\d+\.path$/)) {
            registry_js_1.reg.resetSyncTarget();
        }
        let mustAutoAddResources = false;
        if (action.type === 'SETTING_UPDATE_ONE' && action.key === 'sync.resourceDownloadMode') {
            mustAutoAddResources = true;
        }
        if (action.type === 'DECRYPTION_WORKER_SET' && action.state === 'idle' && action.decryptedItemCounts && !!action.decryptedItemCounts[BaseModel_1.default.TYPE_NOTE]) {
            mustAutoAddResources = true;
        }
        // In general the DecryptionWorker is started via events, such as when an encrypted note
        // is received via sync, or after an encrypted has been downloaded. However, in some cases,
        // in particular when an item cannot be decrypted, the service won't retry automatically,
        // since it's not useful because the data most likely is corrupted. In some
        // cases the user might want to retry anyway, so we enable this by starting the service
        // automatically after each full sync (which is triggered when the user presses the sync
        // button, but not when a note is saved).
        if (action.type === 'SYNC_COMPLETED' && action.isFullSync) {
            void DecryptionWorker_1.default.instance().scheduleStart();
        }
        if (action.type === 'NOTE_DELETE' ||
            action.type === 'NOTE_UPDATE_ALL' ||
            action.type === 'NOTE_TAG_REMOVE' ||
            action.type === 'TAG_UPDATE_ONE') {
            refreshTags = true;
        }
        // handle the case when the selected note has been moved to another
        // folder and a new one is now selected, need to show correct tags for it
        if (action.type === 'NOTE_UPDATE_ONE' && action.changedFields.indexOf('parent_id') >= 0) {
            refreshTags = true;
        }
        if (action.type === 'NOTE_SELECT' || action.type === 'NAV_BACK') {
            const noteIds = newState.provisionalNoteIds.slice();
            for (const noteId of noteIds) {
                if (action.id === noteId)
                    continue;
                registry_js_1.reg.logger().info('Provisional was not modified - deleting it');
                yield Note_1.default.delete(noteId);
            }
        }
        if (action.type === 'NOTE_DELETE' ||
            action.type === 'NOTE_SELECT' ||
            action.type === 'NOTE_SELECT_TOGGLE' ||
            action.type === 'TAG_UPDATE_ONE' ||
            action.type === 'TAG_UPDATE_ALL') {
            let noteTags = [];
            // We don't need to show tags unless only one note is selected.
            // For new notes, the old note is still selected, but we don't want to show any tags.
            if (newState.selectedNoteIds &&
                newState.selectedNoteIds.length === 1) {
                noteTags = yield Tag_1.default.tagsByNoteId(newState.selectedNoteIds[0]);
            }
            store.dispatch({
                type: 'SET_NOTE_TAGS',
                items: noteTags,
            });
        }
        if (mustAutoAddResources) {
            void ResourceFetcher_1.default.instance().autoAddResources();
        }
        if (refreshTags) {
            store.dispatch({
                type: 'TAG_UPDATE_ALL',
                items: yield Tag_1.default.allWithNotes(),
            });
        }
        if (action.type.startsWith('SHARE_')) {
            const serialized = JSON.stringify(newState.shareService);
            Setting_1.default.setValue('sync.shareCache', serialized);
            BaseItem_1.default.syncShareCache = JSON.parse(serialized);
        }
        // For debugging purposes: it seems in some case an empty note is saved to
        // the note array, so in that case display a log statements so that it can
        // be debugged.
        // https://discourse.joplinapp.org/t/how-to-recover-corrupted-database/9367/3?u=laurent
        if (action.type.indexOf('NOTE_') === 0) {
            for (const note of newState.notes) {
                if (!note) {
                    registry_js_1.reg.logger().error('Detected empty element in note array', action);
                }
            }
        }
    });
};
module.exports = reduxSharedMiddleware;
//# sourceMappingURL=reduxSharedMiddleware.js.map